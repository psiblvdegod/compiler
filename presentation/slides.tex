\documentclass{beamer}
\usetheme{CambridgeUS}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\setbeamercolor{item}{fg=red}

\lstset{
	  basicstyle=\bfseries\ttfamily,
	keywordstyle=\bfseries\color{blue},
	commentstyle=\color{gray},
	stringstyle=\color{red},
	backgroundcolor=\color{white},
	frame=single,
	rulecolor=\color{black},
	tabsize=2,
	showstringspaces=false,
	breaklines=true,
	breakatwhitespace=true,
	captionpos=b,
	frame=none,
	numbers=none,
}

\title{Учебный компилятор}
\author[Балышев А.М.]{Автор: Балышев А.М.\\ Руководитель: Косарев Д.С.}

\begin{document}
	
	\begin{frame}[plain]
		\maketitle
	\end{frame}
	
	\begin{frame}
	\frametitle{Язык и платформа}
	\begin{itemize}
			\item Язык — OCaml
			\item Хостинг кода — GitHub
			\item CI/CD — GitHub Actions
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Цель и задачи}
		Цель:
		\\
		Создание AOT-компилятора вымышленного императивного языка, способного компилировать относительно несложные программы 
		
		Задачи:\\
		\begin{itemize}
			\item Реализация фронтенда
			\begin{itemize}
				\item Лексический разбор
				\item Синтаксический разбор
				\item Семантический разбор
			\end{itemize}
			\item Реализация бекенда
			\begin{itemize}
				\item Порождение RISC-V Assembly
			\end{itemize}
			\item Рефакторинг кода и оформление репозитория
		\end{itemize}
		
	\end{frame}
	
		\begin{frame}
		\frametitle{О компилируемом языке}
		\begin{itemize}
			\item Инструкции верхнего уровня
			\item Базовые императивные конструкции
			\begin{itemize}
				\item Объявления и присваивания
				\item Циклы
				\item Ветвления
				\item Вызов процедур
			\end{itemize}
			\item Поддержка типов и областей видимости
			\item Pascal-like синтаксис
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{О процессе компиляции}
			\begin{itemize}
			\item Каждый этап обрабатывается отдельной функцией
			\item Функция принимает некоторое представление программы и возвращает новое представление, снабженное дополнительной информацией
			\item Компиляция представляет собой последовательную передачу результатов вычислений предыдущей функции в следующую функцию
			\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Лексический разбор}
			Задачи:
			\begin{itemize}
				\item Преобразовать строку в последовательность токенов
				\item Выявить лексические ошибки
			\end{itemize}
			Сигнатура функции:

			\begin{lstlisting}[language=ML] 
			val tokenize : string -> token list
			\end{lstlisting}

			В качестве токенов могут выступать:
			\begin{itemize}
				\item Ключевые слова:
				\begin{itemize}
					\item \lstinline[language=ML]|while, do, done, if, then, else, fi ...|
				\end{itemize}
				\item Литералы:
				\begin{itemize}
					\item \lstinline[language=ML]|Int 42, true, false, String "hello world"|
				\end{itemize}
				\item Унарные и бинарные операторы и скобки
				\item Идентификаторы переменных и функций
			\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Синтаксический разбор}
		Задачи:
		\begin{itemize}
			\item Преобразовать последовательность токенов в AST
			\item Выявить синтаксические ошибки
		\end{itemize}
		Сигнатура функции:	
		\begin{lstlisting}[language=ML] 
		val build_ast : token list -> ast
		\end{lstlisting}
		Детали реализации:
		\begin{itemize}
			\item Разбор выражений с помощью рекурсивного спуска
			\item ???
		\end{itemize}
		\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{AST}
		\begin{lstlisting}[language=ML] 
type program = statement list

type statement =
| Assignment of string * expression
| While of expression * program
| Ite of expression * program * program
| ...

type expression =
| Var of string
| Int of int
| BinOp of operation * expression * expression
| ...
		\end{lstlisting}
	\end{frame}
	
		\begin{frame}[fragile]
		\frametitle{Семантический разбор}
		Задачи:
		\begin{itemize}
			\item Дополнить AST информацией о типах и областях видимости
			\item Выявить семантические ошибки
		\end{itemize}
				
		\begin{lstlisting}[language=ML] 
		val annotate_ast : ast -> annotated_ast
		\end{lstlisting}
		
		Поддерживаемые на данный момент типы:
		\begin{itemize}
			\item Int
			\item Bool
			\item ASCIIZ String
		\end{itemize}

		\end{frame}
	\begin{frame}[fragile]
			\frametitle{Annotated AST}

\begin{lstlisting}[language=ML] 
type typed_program = (typed_statement * scope) list

type typed_statement =
| Typed_Assignment of string * typed_expression
| Typed_While of typed_expression * typed_program
| Typed_Ite of typed_expression * typed_program * typed_program
| ...

type typed_expression =
| Type_Int of ...
| Type_Bool of ...
| Type_Str of ...

\end{lstlisting}

		\end{frame}

\begin{frame}[fragile]
	\frametitle{Порождение кода}
	Задача — Преобразование AST в язык Ассемблера
	\\
	Сигнатура функции:
	\begin{lstlisting}[language=ML] 
	val generate_assembly : annotated_ast -> string
	\end{lstlisting}
	
	Порождение кода реализовано только для riscv64
\end{frame}

\begin{frame}
	\frametitle{Дальнейшие этапы}
	\begin{itemize}
		\item Ассемблирование
		\begin{itemize}
			\item Например, с помощью \lstinline[language=Python]|riscv64-unknown-elf-as|
			\item Результат — объектный модуль
		\end{itemize}
		\item Линковка
			\begin{itemize}
				\item Например, с помощью \lstinline[language=Python]|riscv64-unknown-elf-ld|
				\item Результат — исполняемый файл
			\end{itemize}
		\item Исполнение
		\begin{itemize}
			\item Нативно, если архитектура соответствующая
			\item С помощью эмулятора, например \lstinline[language=Python]|qemu|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Пример}
	\begin{itemize}
		\begin{lstlisting}[language=PASCAL]
var left right;
left := -7; right := 8;
while left < right do
		var n acc sign;
		n := left;
		acc := 1;
		sign := n < 0;
		while n != 0 do
				acc := acc * n;  
				if sign then n := n + 1;
				else  n := n - 1;
				fi
		done
		left := left + 1;
		printn acc;
done
		\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{О проблемах и решениях}
	\begin{itemize}
		\item При выделении места на стеке для локальных переменных при выходе из области видимости нужно восстановить \lstinline[language=Python]|sp|
		\begin{itemize}		
			\item Можно хранить текущее количество переменных
		\end{itemize}
		\item Метки для условных/безусловных переходов не должны повторяться
		\begin{itemize}		
			\item Можно генерировать их случайно
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Использовавшиеся инструменты}
		\begin{itemize}
			\item \lstinline[language=Python]|ppx_expect|,  \lstinline[language=Python]|ppx_deriving|
			\begin{itemize}
				\item Специфичные для OCaml фреймворки значительно упрощающие тестирование и отладку
			\end{itemize}
			
			\item \lstinline[language=Python]|riscv64-unknown-elf-as|,  \lstinline[language=Python]|riscv64-unknown-elf-ld|
			\item \lstinline[language=Python]|qemu-riscv64|, \lstinline[language=Python]|spike|
		\end{itemize}
\end{frame}
\end{document}
