open Types
open Printf

exception ReDeclaration_attempt
exception Unbound_value
exception Not_supported

type generator_state =
{
  vars : string list;
  acc : string;
  sp : int;
}

let alignment = 16

let append_to_acc state str = { vars = state.vars; sp = state.sp; acc = state.acc ^ str }

let rec process_declaration state = function
  | [] -> state
  | name :: rest ->
  if List.mem name state.vars
  then raise ReDeclaration_attempt
  else let new_state =
  {
    vars = name :: state.vars;
    sp = state.sp + alignment;
    acc = state.acc ^ (sprintf "addi sp, sp, %d\n" (-alignment));
  } in process_declaration new_state rest

let rec index_of value acc = function
| [] -> None
| head :: rest -> if head = value then Some acc else index_of value (acc + 1) rest

let index_of value ls = index_of value 0 ls

let index_of_var_or_raise state name =
  match index_of name state.vars with
  | Some index -> index
  | None -> raise Unbound_value

let lw_t1_by_index index =
    sprintf "lw t1, %d(sp)\n" (index * alignment)

let push value =
    sprintf
"addi sp, sp, %d
li t1, %d
sw t1, 0(sp)\n" (-alignment) value

let generate_label =
  let length = 16 in
  let buffer = Bytes.create length in
  let random_letter =
    Char.chr (Char.code 'a' + Random.int 26) in
  for i = 0 to length - 1 do Bytes.set buffer i random_letter done;
  buffer |> Bytes.to_string

let apply_binop binop =
sprintf
"
lw t2, (sp)
lw t1, %d(sp)
addi sp, sp, %d

\n%s t1, t1, t2
sw t1, (sp)\n
" alignment alignment binop

let rec parse_expressions state cnt = function
  | [] -> state
  | Int value :: rest -> parse_expressions (push value |> append_to_acc state) (cnt + 1) rest
  | Var name :: rest ->
    let index = index_of_var_or_raise state name in
    let stm = lw_t1_by_index (index + cnt) ^ sprintf "addi sp, sp, %d\n" (-alignment) ^ "sw t1, (sp)\n" in
    parse_expressions (append_to_acc state stm) (cnt + 1) rest
  | Add(left, right) :: rest ->
    let parse_operands = parse_expressions state cnt [left; right] in
    let new_state = append_to_acc parse_operands (apply_binop "add") in
    parse_expressions new_state (cnt + 1) rest
  | Sub(left, right) :: rest ->
    let parse_operands = parse_expressions state cnt [left; right] in
    let new_state = append_to_acc parse_operands (apply_binop "sub") in
    parse_expressions new_state (cnt + 1) rest
  | Mul(left, right) :: rest ->
    let parse_operands = parse_expressions state cnt [left; right] in
    let new_state = append_to_acc parse_operands (apply_binop "mul") in
    parse_expressions new_state (cnt + 1) rest
  | Div(left, right) :: rest ->
    let parse_operands = parse_expressions state cnt [left; right] in
    let new_state = append_to_acc parse_operands (apply_binop "div") in
    parse_expressions new_state (cnt + 1) rest
  | _ -> raise Not_supported

let parse_expressions state expressions = parse_expressions state 0 expressions

let destruct_condition do_label = function
  | Eq(left, right) -> left, right, sprintf "beq t1, t2, %s\n" do_label
  | Neq(left, right) -> left, right, sprintf "bne t1, t2, %s\n" do_label
  | Leq(left, right) -> left, right, sprintf "ble t1, t2, %s\n" do_label
  | Geq(left, right) -> left, right, sprintf "bge t1, t2, %s\n" do_label
  | Lt(left, right) -> left, right, sprintf "blt t1, t2, %s\n" do_label
  | Gt(left, right) -> left, right, sprintf "bgt t1, t2, %s\n" do_label

let lang_print state = function
| [] -> Invalid_argument "at least 1 argument expected." |> raise
| args ->
  let rec loop cnt state =
    if cnt = 0 then state else
      let pop = "lw a0, (sp)\n" ^ sprintf "addi sp, sp, %d\n" alignment in
      pop ^ "call print_number\n" |> append_to_acc state |> loop (cnt - 1) in
  
  parse_expressions state (List.rev args) |> loop (List.length args)

let process_calling state name args =
  match name with
  | "print" -> lang_print state args
  | _ -> raise Not_supported

let process_assignment state dest expression =
  let dest_index = index_of_var_or_raise state dest in
  let pop_and_sw = "lw t1, 0(sp)\n" ^ "addi sp, sp, 16\n" ^ (sprintf "sw t1, %d(sp)\n" (alignment * dest_index)) in
  let new_state = parse_expressions state [expression] in
  append_to_acc new_state pop_and_sw

let rec assembly_of_program state = function
  | [] -> state.acc
  | statement :: rest ->
  match statement with
  | Declaration names ->
    let new_state = process_declaration state names in
    assembly_of_program new_state rest
  | Assignment(name,expression) ->
    let new_state = process_assignment state name expression in
    assembly_of_program new_state rest
  | Call(name, args) ->
    let new_state = process_calling state name args in
    assembly_of_program new_state rest
  | _ -> raise Not_supported

(*

examle of (expected) code generated by process_while:

while:

<code generated to calculate comparison operands and put em to t1, t2>

beq t1, t2, do
j done
do:

<code generated by assembly_of_program>

j while
done:

*)

(*
and process_while state condition statements =
  let while_label = generate_label in
  let do_label = generate_label in
  let done_label = generate_label in
  let left, right, check = destruct_condition do_label condition in
  let calc_left, left_cnt = parse_expression state 0 left in
  let calc_right, right_cnt = parse_expression state left_cnt right in
  let lw_left = sprintf "lw t1, %d(sp)\n" (alignment * (right_cnt - left_cnt)) in
  let lw_right = "lw t2, 0(sp)\n" in
  let pre = while_label ^ ":\n" ^ calc_left ^ calc_right ^ lw_left ^ lw_right ^ check ^ (sprintf "j %s\n" done_label) ^ do_label ^ ":\n" in
  let post = sprintf "j %s\n" while_label ^ done_label ^ ":\n" in
  
*)
let init_state =
{
  vars = [];
  sp = 0;
  acc = String.empty
}

let assembly_of_program program = assembly_of_program init_state program
